"""
Simple Genetic Algorithm (SGA) for campaign optimization.

This module implements a genetic algorithm specifically tailored for optimizing
campaign parameters in the Mercado Livre context, including budget allocation,
bidding strategies, and targeting parameters.
"""

import random
import logging
import numpy as np
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from dataclasses import dataclass
from copy import deepcopy

from .optimizer import OptimizationResult

logger = logging.getLogger(__name__)


@dataclass
class GeneticConfig:
    """Configuration parameters for the genetic algorithm."""
    population_size: int = 50
    max_generations: int = 100
    crossover_rate: float = 0.8
    mutation_rate: float = 0.1
    tournament_size: int = 3
    elitism_rate: float = 0.1
    convergence_threshold: float = 1e-6
    max_stagnant_generations: int = 20


class Chromosome:
    """
    Represents a chromosome (solution) in the genetic algorithm.
    
    A chromosome encodes campaign parameters as genes, including:
    - Budget allocation across campaigns
    - Bidding parameters (max_cpc, target_cpa)
    - Targeting parameters (location_radius, audience_expansion)
    """
    
    def __init__(self, genes: Dict[str, float], parameter_bounds: Dict[str, Tuple[float, float]]):
        """
        Initialize a chromosome with genes and parameter bounds.
        
        Args:
            genes: Dictionary mapping parameter names to values
            parameter_bounds: Dictionary mapping parameter names to (min, max) bounds
        """
        self.genes = genes.copy()
        self.parameter_bounds = parameter_bounds
        self.fitness = 0.0
        self.evaluated = False
    
    def validate_genes(self):
        """Validate and clip genes to their bounds."""
        for param, value in self.genes.items():
            if param in self.parameter_bounds:
                min_val, max_val = self.parameter_bounds[param]
                self.genes[param] = max(min_val, min(max_val, value))
    
    def copy(self) -> 'Chromosome':
        """Create a deep copy of the chromosome."""
        new_chromosome = Chromosome(self.genes, self.parameter_bounds)
        new_chromosome.fitness = self.fitness
        new_chromosome.evaluated = self.evaluated
        return new_chromosome
    
    def __repr__(self):
        return f"Chromosome(fitness={self.fitness:.4f}, genes={self.genes})"


class GeneticOptimizer:
    """
    Genetic Algorithm optimizer for campaign parameters.
    
    This class implements a Simple Genetic Algorithm (SGA) with:
    - Tournament selection
    - Single-point and two-point crossover
    - Random mutation
    - Elitism
    - Fitness evaluation based on campaign performance metrics
    """
    
    def __init__(self, config: Optional[GeneticConfig] = None):
        """
        Initialize the genetic optimizer.
        
        Args:
            config: Configuration parameters for the genetic algorithm
        """
        self.config = config or GeneticConfig()
        self.population = []
        self.best_chromosome = None
        self.generation = 0
        self.fitness_history = []
        self.parameter_bounds = {}
        self.constraints = {}
        
        # Set random seed for reproducible results in testing
        random.seed(42)
        np.random.seed(42)
    
    def set_parameter_bounds(self, bounds: Dict[str, Tuple[float, float]]):
        """
        Set bounds for optimization parameters.
        
        Args:
            bounds: Dictionary mapping parameter names to (min, max) bounds
        """
        self.parameter_bounds = bounds
        logger.info(f"Set parameter bounds for {len(bounds)} parameters")
    
    def set_constraints(self, constraints: Dict[str, Dict[str, float]]):
        """
        Set optimization constraints for parameters.
        
        Args:
            constraints: Dict with parameter names and their min/max bounds
        """
        self.constraints = constraints
        # Convert constraints to parameter bounds format
        bounds = {}
        for param, constraint in constraints.items():
            if 'min' in constraint and 'max' in constraint:
                bounds[param] = (constraint['min'], constraint['max'])
        self.set_parameter_bounds(bounds)
    
    def initialize_population(self, parameter_template: Dict[str, Any]) -> List[Chromosome]:
        """
        Initialize the population with random chromosomes.
        
        Args:
            parameter_template: Template with parameter names and default values
            
        Returns:
            List of initialized chromosomes
        """
        population = []
        
        for _ in range(self.config.population_size):
            genes = {}
            for param, default_value in parameter_template.items():
                if param in self.parameter_bounds:
                    min_val, max_val = self.parameter_bounds[param]
                    # Generate random value within bounds
                    genes[param] = random.uniform(min_val, max_val)
                else:
                    # Use default value with some random variation
                    if isinstance(default_value, (int, float)):
                        variation = 0.2  # 20% variation
                        genes[param] = default_value * (1 + random.uniform(-variation, variation))
                    else:
                        genes[param] = default_value
            
            chromosome = Chromosome(genes, self.parameter_bounds)
            chromosome.validate_genes()
            population.append(chromosome)
        
        logger.info(f"Initialized population with {len(population)} chromosomes")
        return population
    
    def evaluate_fitness(self, chromosome: Chromosome, campaigns: List[Dict[str, Any]], 
                        objective: str = "maximize_roi") -> float:
        """
        Evaluate the fitness of a chromosome based on campaign performance metrics.
        
        Args:
            chromosome: Chromosome to evaluate
            campaigns: List of campaign configurations
            objective: Optimization objective
            
        Returns:
            Fitness score (higher is better)
        """
        try:
            # Simulate campaign performance with the chromosome's parameters
            total_fitness = 0.0
            
            for i, campaign in enumerate(campaigns):
                # Get campaign-specific parameters from chromosome
                campaign_budget_key = f"campaign_{i}_budget"
                campaign_budget = chromosome.genes.get(campaign_budget_key, campaign.get("daily_budget", 1000))
                
                # Get other optimization parameters
                max_cpc = chromosome.genes.get("max_cpc", campaign.get("max_cpc", 1.0))
                location_radius = chromosome.genes.get("location_radius", campaign.get("location_radius", 25))
                
                # Calculate performance metrics based on parameters
                base_roi = campaign.get("historical_roi", 2.0)
                base_conversion_rate = campaign.get("historical_conversion_rate", 0.02)
                base_ctr = campaign.get("historical_ctr", 0.01)
                
                # Adjust metrics based on parameters
                # Higher budget generally improves reach but with diminishing returns
                budget_factor = min(1.5, 1.0 + 0.0001 * campaign_budget)
                
                # Optimal CPC range - too low reduces visibility, too high reduces efficiency
                optimal_cpc = campaign.get("optimal_cpc", 1.5)
                cpc_factor = 1.0 - abs(max_cpc - optimal_cpc) / optimal_cpc * 0.3
                cpc_factor = max(0.5, min(1.3, cpc_factor))
                
                # Location radius affects reach and conversion
                optimal_radius = campaign.get("optimal_radius", 30)
                radius_factor = 1.0 - abs(location_radius - optimal_radius) / optimal_radius * 0.2
                radius_factor = max(0.7, min(1.2, radius_factor))
                
                # Calculate adjusted metrics
                adjusted_roi = base_roi * cpc_factor * radius_factor
                adjusted_conversion_rate = base_conversion_rate * budget_factor * radius_factor
                adjusted_ctr = base_ctr * budget_factor * cpc_factor
                
                # Calculate fitness based on objective
                if objective == "maximize_roi":
                    campaign_fitness = adjusted_roi * campaign_budget
                elif objective == "maximize_conversions":
                    campaign_fitness = adjusted_conversion_rate * campaign_budget * 1000
                elif objective == "maximize_clicks":
                    campaign_fitness = adjusted_ctr * campaign_budget * 10000
                else:
                    # Combined objective
                    campaign_fitness = (adjusted_roi * adjusted_conversion_rate * adjusted_ctr * 
                                      campaign_budget * 100)
                
                total_fitness += campaign_fitness
            
            # Apply penalties for constraint violations
            penalty = 0.0
            total_budget = sum(chromosome.genes.get(f"campaign_{i}_budget", campaigns[i].get("daily_budget", 1000)) 
                             for i in range(len(campaigns)))
            
            # Budget constraint penalty
            if "total_budget_limit" in self.constraints:
                budget_limit = self.constraints["total_budget_limit"].get("max", float('inf'))
                if total_budget > budget_limit:
                    penalty += (total_budget - budget_limit) * 10
            
            fitness = max(0.1, total_fitness - penalty)
            chromosome.fitness = fitness
            chromosome.evaluated = True
            
            return fitness
            
        except Exception as e:
            logger.error(f"Fitness evaluation failed: {str(e)}")
            chromosome.fitness = 0.1
            chromosome.evaluated = True
            return 0.1
    
    def tournament_selection(self, population: List[Chromosome]) -> Chromosome:
        """
        Select a parent using tournament selection.
        
        Args:
            population: Population of chromosomes
            
        Returns:
            Selected chromosome
        """
        tournament = random.sample(population, min(self.config.tournament_size, len(population)))
        return max(tournament, key=lambda x: x.fitness)
    
    def single_point_crossover(self, parent1: Chromosome, parent2: Chromosome) -> Tuple[Chromosome, Chromosome]:
        """
        Perform single-point crossover between two parents.
        
        Args:
            parent1: First parent chromosome
            parent2: Second parent chromosome
            
        Returns:
            Tuple of two offspring chromosomes
        """
        if random.random() > self.config.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        # Get list of parameter names
        params = list(parent1.genes.keys())
        if len(params) <= 1:
            # Can't do crossover with one or no parameters
            return parent1.copy(), parent2.copy()
        
        # Choose crossover point
        crossover_point = random.randint(1, len(params) - 1)
        
        # Create offspring
        offspring1_genes = {}
        offspring2_genes = {}
        
        for i, param in enumerate(params):
            if i < crossover_point:
                offspring1_genes[param] = parent1.genes[param]
                offspring2_genes[param] = parent2.genes[param]
            else:
                offspring1_genes[param] = parent2.genes[param]
                offspring2_genes[param] = parent1.genes[param]
        
        offspring1 = Chromosome(offspring1_genes, self.parameter_bounds)
        offspring2 = Chromosome(offspring2_genes, self.parameter_bounds)
        
        offspring1.validate_genes()
        offspring2.validate_genes()
        
        return offspring1, offspring2
    
    def two_point_crossover(self, parent1: Chromosome, parent2: Chromosome) -> Tuple[Chromosome, Chromosome]:
        """
        Perform two-point crossover between two parents.
        
        Args:
            parent1: First parent chromosome
            parent2: Second parent chromosome
            
        Returns:
            Tuple of two offspring chromosomes
        """
        if random.random() > self.config.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        # Get list of parameter names
        params = list(parent1.genes.keys())
        if len(params) < 3:
            return self.single_point_crossover(parent1, parent2)
        
        # Choose two crossover points
        point1 = random.randint(1, len(params) - 2)
        point2 = random.randint(point1 + 1, len(params) - 1)
        
        # Create offspring
        offspring1_genes = {}
        offspring2_genes = {}
        
        for i, param in enumerate(params):
            if i < point1 or i >= point2:
                offspring1_genes[param] = parent1.genes[param]
                offspring2_genes[param] = parent2.genes[param]
            else:
                offspring1_genes[param] = parent2.genes[param]
                offspring2_genes[param] = parent1.genes[param]
        
        offspring1 = Chromosome(offspring1_genes, self.parameter_bounds)
        offspring2 = Chromosome(offspring2_genes, self.parameter_bounds)
        
        offspring1.validate_genes()
        offspring2.validate_genes()
        
        return offspring1, offspring2
    
    def mutate(self, chromosome: Chromosome) -> Chromosome:
        """
        Apply random mutation to a chromosome.
        
        Args:
            chromosome: Chromosome to mutate
            
        Returns:
            Mutated chromosome
        """
        mutated = chromosome.copy()
        
        for param in mutated.genes.keys():
            if random.random() < self.config.mutation_rate:
                if param in self.parameter_bounds:
                    min_val, max_val = self.parameter_bounds[param]
                    # Gaussian mutation within bounds
                    current_val = mutated.genes[param]
                    mutation_strength = (max_val - min_val) * 0.1  # 10% of range
                    mutation = random.gauss(0, mutation_strength)
                    mutated.genes[param] = max(min_val, min(max_val, current_val + mutation))
                else:
                    # For unbounded parameters, apply small relative mutation
                    current_val = mutated.genes[param]
                    if isinstance(current_val, (int, float)) and current_val != 0:
                        mutation_factor = 1 + random.gauss(0, 0.1)  # 10% standard deviation
                        mutated.genes[param] = current_val * mutation_factor
        
        mutated.validate_genes()
        mutated.evaluated = False
        return mutated
    
    def get_elite(self, population: List[Chromosome]) -> List[Chromosome]:
        """
        Get the elite chromosomes from the population.
        
        Args:
            population: Population of chromosomes
            
        Returns:
            List of elite chromosomes
        """
        elite_count = max(1, int(len(population) * self.config.elitism_rate))
        sorted_population = sorted(population, key=lambda x: x.fitness, reverse=True)
        return [chromosome.copy() for chromosome in sorted_population[:elite_count]]
    
    def optimize_budget_allocation(self, campaigns: List[Dict[str, Any]], 
                                 total_budget: float,
                                 objective: str = "maximize_roi") -> OptimizationResult:
        """
        Optimize budget allocation across campaigns using genetic algorithm.
        
        Args:
            campaigns: List of campaign configurations
            total_budget: Total budget to allocate
            objective: Optimization objective
            
        Returns:
            OptimizationResult with optimized budget allocation
        """
        try:
            logger.info(f"Starting genetic optimization for {len(campaigns)} campaigns")
            
            # Set up parameter template and bounds
            parameter_template = {}
            bounds = {}
            
            for i, campaign in enumerate(campaigns):
                param_name = f"campaign_{i}_budget"
                parameter_template[param_name] = campaign.get("daily_budget", total_budget / len(campaigns))
                bounds[param_name] = (10.0, total_budget * 0.8)  # Min 10, max 80% of total budget
            
            # Add constraint for total budget
            self.constraints["total_budget_limit"] = {"max": total_budget}
            self.set_parameter_bounds(bounds)
            
            # Initialize population
            self.population = self.initialize_population(parameter_template)
            self.generation = 0
            self.fitness_history = []
            best_fitness_history = []
            stagnant_generations = 0
            
            # Evaluate initial population
            for chromosome in self.population:
                self.evaluate_fitness(chromosome, campaigns, objective)
            
            self.best_chromosome = max(self.population, key=lambda x: x.fitness)
            logger.info(f"Initial best fitness: {self.best_chromosome.fitness:.4f}")
            
            # Main genetic algorithm loop
            for generation in range(self.config.max_generations):
                self.generation = generation
                
                # Selection and reproduction
                new_population = []
                
                # Keep elite
                elite = self.get_elite(self.population)
                new_population.extend(elite)
                
                # Generate offspring
                while len(new_population) < self.config.population_size:
                    parent1 = self.tournament_selection(self.population)
                    parent2 = self.tournament_selection(self.population)
                    
                    # Choose crossover type randomly
                    if random.random() < 0.5:
                        offspring1, offspring2 = self.single_point_crossover(parent1, parent2)
                    else:
                        offspring1, offspring2 = self.two_point_crossover(parent1, parent2)
                    
                    # Apply mutation
                    offspring1 = self.mutate(offspring1)
                    offspring2 = self.mutate(offspring2)
                    
                    new_population.extend([offspring1, offspring2])
                
                # Trim population to exact size
                new_population = new_population[:self.config.population_size]
                
                # Evaluate new population
                for chromosome in new_population:
                    if not chromosome.evaluated:
                        self.evaluate_fitness(chromosome, campaigns, objective)
                
                self.population = new_population
                
                # Update best chromosome
                current_best = max(self.population, key=lambda x: x.fitness)
                
                if current_best.fitness > self.best_chromosome.fitness:
                    self.best_chromosome = current_best.copy()
                    stagnant_generations = 0
                    logger.info(f"Generation {generation}: New best fitness {self.best_chromosome.fitness:.4f}")
                else:
                    stagnant_generations += 1
                
                # Track fitness history
                avg_fitness = sum(c.fitness for c in self.population) / len(self.population)
                self.fitness_history.append(avg_fitness)
                best_fitness_history.append(self.best_chromosome.fitness)
                
                # Check convergence
                if stagnant_generations >= self.config.max_stagnant_generations:
                    logger.info(f"Converged after {generation + 1} generations (stagnation)")
                    break
                
                if generation > 10:
                    recent_improvement = best_fitness_history[-1] - best_fitness_history[-10]
                    if recent_improvement < self.config.convergence_threshold:
                        logger.info(f"Converged after {generation + 1} generations (threshold)")
                        break
            
            # Prepare results
            optimized_parameters = {}
            total_allocated = 0
            
            # Normalize budget allocation to meet total budget constraint
            raw_allocations = []
            for i in range(len(campaigns)):
                param_name = f"campaign_{i}_budget"
                allocation = self.best_chromosome.genes.get(param_name, 0)
                raw_allocations.append(allocation)
                total_allocated += allocation
            
            # Scale allocations to meet total budget
            if total_allocated > 0:
                scale_factor = total_budget / total_allocated
                for i in range(len(campaigns)):
                    param_name = f"campaign_{i}_budget"
                    scaled_allocation = raw_allocations[i] * scale_factor
                    optimized_parameters[param_name] = round(scaled_allocation, 2)
            else:
                # Equal allocation if optimization failed
                equal_allocation = total_budget / len(campaigns)
                for i in range(len(campaigns)):
                    param_name = f"campaign_{i}_budget"
                    optimized_parameters[param_name] = round(equal_allocation, 2)
            
            # Calculate expected improvement
            current_performance = sum(c.get("current_performance", 1000) for c in campaigns)
            expected_improvement = current_performance * 0.25  # Genetic algorithm typically finds better solutions
            
            return OptimizationResult(
                optimized_parameters=optimized_parameters,
                expected_improvement=expected_improvement,
                confidence_score=0.9,
                optimization_method="genetic_algorithm",
                iterations_used=self.generation + 1,
                timestamp=datetime.now(),
                metadata={
                    "total_budget": total_budget,
                    "objective": objective,
                    "campaigns_count": len(campaigns),
                    "population_size": self.config.population_size,
                    "best_fitness": self.best_chromosome.fitness,
                    "final_generation": self.generation,
                    "convergence_reason": "stagnation" if stagnant_generations >= self.config.max_stagnant_generations else "threshold"
                }
            )
            
        except Exception as e:
            logger.error(f"Genetic optimization failed: {str(e)}")
            raise
    
    def optimize_campaign_parameters(self, current_params: Dict[str, Any],
                                   performance_history: List[Dict[str, Any]]) -> OptimizationResult:
        """
        Optimize general campaign parameters using genetic algorithm.
        
        Args:
            current_params: Current campaign parameters
            performance_history: Historical performance data
            
        Returns:
            OptimizationResult with optimized parameters
        """
        try:
            logger.info("Starting genetic optimization for campaign parameters")
            
            # Set up parameter template and bounds
            parameter_template = current_params.copy()
            bounds = {
                "max_cpc": (0.1, 5.0),
                "location_radius": (5.0, 100.0),
                "daily_budget": (50.0, 5000.0),
                "target_cpa": (10.0, 200.0)
            }
            
            # Only include parameters that exist in current_params
            bounds = {k: v for k, v in bounds.items() if k in parameter_template}
            self.set_parameter_bounds(bounds)
            
            # Initialize smaller population for parameter optimization
            original_pop_size = self.config.population_size
            self.config.population_size = 20  # Smaller population for parameter optimization
            
            self.population = self.initialize_population(parameter_template)
            self.generation = 0
            self.fitness_history = []
            
            # Create a mock campaign for fitness evaluation
            mock_campaigns = [{
                "historical_roi": sum(p.get("roi", 2.0) for p in performance_history) / len(performance_history) if performance_history else 2.0,
                "historical_conversion_rate": sum(p.get("conversion_rate", 0.02) for p in performance_history) / len(performance_history) if performance_history else 0.02,
                "historical_ctr": 0.01,
                "daily_budget": current_params.get("daily_budget", 1000),
                "optimal_cpc": 1.5,
                "optimal_radius": 30
            }]
            
            # Evaluate initial population
            for chromosome in self.population:
                self.evaluate_fitness(chromosome, mock_campaigns, "maximize_roi")
            
            self.best_chromosome = max(self.population, key=lambda x: x.fitness)
            
            # Run genetic algorithm for fewer generations
            max_gens = min(50, self.config.max_generations)
            for generation in range(max_gens):
                self.generation = generation
                
                # Selection and reproduction
                new_population = []
                
                # Keep elite
                elite = self.get_elite(self.population)
                new_population.extend(elite)
                
                # Generate offspring
                while len(new_population) < self.config.population_size:
                    parent1 = self.tournament_selection(self.population)
                    parent2 = self.tournament_selection(self.population)
                    
                    offspring1, offspring2 = self.single_point_crossover(parent1, parent2)
                    offspring1 = self.mutate(offspring1)
                    offspring2 = self.mutate(offspring2)
                    
                    new_population.extend([offspring1, offspring2])
                
                new_population = new_population[:self.config.population_size]
                
                # Evaluate new population
                for chromosome in new_population:
                    if not chromosome.evaluated:
                        self.evaluate_fitness(chromosome, mock_campaigns, "maximize_roi")
                
                self.population = new_population
                current_best = max(self.population, key=lambda x: x.fitness)
                
                if current_best.fitness > self.best_chromosome.fitness:
                    self.best_chromosome = current_best.copy()
            
            # Restore original population size
            self.config.population_size = original_pop_size
            
            # Prepare results
            optimized_parameters = self.best_chromosome.genes.copy()
            
            # Calculate expected improvement
            current_performance = mock_campaigns[0]["historical_roi"] * 1000
            expected_improvement = current_performance * 0.20  # 20% improvement
            
            return OptimizationResult(
                optimized_parameters=optimized_parameters,
                expected_improvement=expected_improvement,
                confidence_score=0.85,
                optimization_method="genetic_algorithm",
                iterations_used=self.generation + 1,
                timestamp=datetime.now(),
                metadata={
                    "parameter_count": len(optimized_parameters),
                    "performance_history_points": len(performance_history),
                    "best_fitness": self.best_chromosome.fitness,
                    "final_generation": self.generation
                }
            )
            
        except Exception as e:
            logger.error(f"Parameter optimization failed: {str(e)}")
            raise